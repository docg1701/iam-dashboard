#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Clean Test Summary Generator
 * 
 * This script processes the large test-summary.json file generated by Vitest
 * and creates a lightweight version without the bulky coverageMap data.
 * 
 * Problem: test-summary.json is 344KB+ due to detailed coverage maps
 * Solution: Extract only essential test results, keep failure details
 */

const possibleInputFiles = [
  path.join(__dirname, '../apps/web/test-summary.json'),
  path.join(__dirname, '../apps/web/coverage/test-results.json'),
];
const outputFile = path.join(__dirname, '../apps/web/test-summary-clean.json');

function findInputFile() {
  for (const file of possibleInputFiles) {
    if (fs.existsSync(file)) {
      return file;
    }
  }
  return null;
}

function consolidatePartialCoverage() {
  const coverageTmpDir = path.join(__dirname, '../apps/web/coverage/.tmp');
  const coverageDir = path.join(__dirname, '../apps/web/coverage');
  
  if (fs.existsSync(coverageTmpDir)) {
    console.log('üìä Found partial coverage data in .tmp/');
    console.log('   Note: Full HTML report requires successful test completion');
    
    // Create a basic summary from partial data
    const partialFiles = fs.readdirSync(coverageTmpDir)
      .filter(f => f.endsWith('.json'));
    
    const summary = {
      timestamp: new Date().toISOString(),
      partial: true,
      coverageFiles: partialFiles.length,
      note: 'Partial coverage - tests did not complete successfully',
      location: coverageTmpDir,
      instruction: 'Run tests with coverage profile for full HTML report'
    };
    
    const summaryFile = path.join(coverageDir, 'partial-coverage-summary.json');
    fs.writeFileSync(summaryFile, JSON.stringify(summary, null, 2));
    console.log(`‚úÖ Partial coverage summary created: ${path.basename(summaryFile)}`);
    return true;
  }
  return false;
}

function cleanTestSummary() {
  try {
    // Find the input file from possible locations
    const inputFile = findInputFile();
    if (!inputFile) {
      console.log('‚ö†Ô∏è  No test summary file found. Checked:');
      possibleInputFiles.forEach(f => console.log(`     - ${f}`));
      
      // Try to consolidate partial coverage if available
      const hasPartialCoverage = consolidatePartialCoverage();
      
      if (hasPartialCoverage) {
        console.log('   ‚ÑπÔ∏è  Partial coverage data was preserved.');
        console.log('   üí° Run tests successfully to generate full reports.');
        process.exit(0); // Exit gracefully when partial coverage is found
      } else {
        console.log('   Run tests first to generate test results.');
        process.exit(1);
      }
    }
    
    console.log(`üìã Found test results: ${path.basename(inputFile)}`);
    console.log('üìã Cleaning test summary...');
    
    // Read and parse the large file
    const rawData = fs.readFileSync(inputFile, 'utf8');
    const fullSummary = JSON.parse(rawData);
    
    // Create cleaned summary with essential data only
    const cleanedSummary = {
      // Test execution metadata
      timestamp: new Date().toISOString(),
      
      // Core test statistics
      numTotalTestSuites: fullSummary.numTotalTestSuites,
      numPassedTestSuites: fullSummary.numPassedTestSuites,
      numFailedTestSuites: fullSummary.numFailedTestSuites,
      numPendingTestSuites: fullSummary.numPendingTestSuites,
      
      numTotalTests: fullSummary.numTotalTests,
      numPassedTests: fullSummary.numPassedTests,
      numFailedTests: fullSummary.numFailedTests,
      numPendingTests: fullSummary.numPendingTests,
      numTodoTests: fullSummary.numTodoTests,
      
      // Overall success status
      success: fullSummary.success,
      
      // Execution time
      executionTime: fullSummary.endTime - fullSummary.startTime,
      
      // Snapshot info (usually small)
      snapshot: fullSummary.snapshot,
      
      // Cleaned test results (without excessive detail)
      testResults: fullSummary.testResults?.map(result => ({
        // File name and basic info
        name: result.name,
        status: result.status,
        
        // Timing information
        startTime: result.startTime,
        endTime: result.endTime,
        duration: result.endTime - result.startTime,
        
        // Test counts for this suite
        numPassedTests: result.assertionResults?.filter(t => t.status === 'passed').length || 0,
        numFailedTests: result.assertionResults?.filter(t => t.status === 'failed').length || 0,
        numPendingTests: result.assertionResults?.filter(t => t.status === 'pending').length || 0,
        
        // Failed tests details (important for debugging)
        failedTests: result.assertionResults?.filter(t => t.status === 'failed').map(test => ({
          title: test.title,
          fullName: test.fullName,
          ancestorTitles: test.ancestorTitles,
          failureMessages: test.failureMessages,
          duration: test.duration
        })) || [],
        
        // Passed tests summary (minimal info)
        passedTests: result.assertionResults?.filter(t => t.status === 'passed').map(test => ({
          title: test.title,
          duration: test.duration
        })) || []
      })) || [],
      
      // Coverage summary (high-level stats only, not line-by-line maps)
      coverageSummary: fullSummary.coverageMap ? {
        note: "Detailed coverage maps removed to reduce file size",
        detailedCoverageLocation: "./coverage/coverage-final.json",
        htmlReportLocation: "./coverage/index.html",
        numCoveredFiles: Object.keys(fullSummary.coverageMap).length
      } : null
    };
    
    // Write cleaned summary
    fs.writeFileSync(outputFile, JSON.stringify(cleanedSummary, null, 2));
    
    // Report size reduction
    const originalSize = fs.statSync(inputFile).size;
    const cleanedSize = fs.statSync(outputFile).size;
    const reduction = ((originalSize - cleanedSize) / originalSize * 100).toFixed(1);
    
    console.log(`‚úÖ Clean summary created:`);
    console.log(`   üìÑ Original: ${(originalSize / 1024).toFixed(1)}KB`);
    console.log(`   üìÑ Cleaned: ${(cleanedSize / 1024).toFixed(1)}KB`);
    console.log(`   üìâ Reduction: ${reduction}%`);
    console.log(`   üìç Location: ${outputFile}`);
    
    // Show test status summary
    if (cleanedSummary.numFailedTests > 0) {
      console.log(`\n‚ùå Tests failing: ${cleanedSummary.numFailedTests}/${cleanedSummary.numTotalTests}`);
      cleanedSummary.testResults.forEach(suite => {
        if (suite.failedTests.length > 0) {
          console.log(`   üì¶ ${path.basename(suite.name)}:`);
          suite.failedTests.forEach(test => {
            console.log(`      ‚ùå ${test.title}`);
          });
        }
      });
    } else {
      console.log(`\n‚úÖ All tests passing: ${cleanedSummary.numPassedTests}/${cleanedSummary.numTotalTests}`);
    }
    
  } catch (error) {
    console.error('‚ùå Error cleaning test summary:', error.message);
    process.exit(1);
  }
}

// Run the cleanup
cleanTestSummary();